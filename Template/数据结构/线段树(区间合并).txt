//用于处理区间最长连续递增子区间
struct Info{
    int mx = 0, pre = 0, suf = 0, pmx = 0, smn = 1e9, siz = 0;
};

Info operator+(const Info &l, const Info &r){
    if(l.siz == 0)
        return r;
    if(r.siz == 0)
        return l;
    
    Info res;
    res.mx = max(l.mx, r.mx);
    res.pre = l.pre, res.pmx = l.pmx;
    res.suf = r.suf, res.smn = r.smn;
    res.siz = l.siz + r.siz;

    if(l.smn > r.pmx) {
        res.mx = max(res.mx, l.suf + r.pre);
        if(l.suf == l.siz) { //头部贯通
            res.pre = l.siz + r.pre;
        }
        if(r.pre == r.siz) { //尾部贯通
            res.suf = l.suf + r.siz;
        }
    }
    return res;
}

struct SegmentTree{
    int n;
    vector<Info> info;
 
    SegmentTree() {}
    SegmentTree(int _n, vector<int> &a) {
        init(_n, a);
    }   

    void init(int _n, vector<int> &a){
        n = _n;
        info.assign(n << 2, Info());
        build(1, 1, n, a);
    }
    
    void build(int p, int l, int r, vector<int> &a){
        if (l == r){
            info[p] = {1, 1, 1, a[l - 1], a[l - 1], 1};
        }else{
            int mid = (l + r) / 2;
            build(2 * p, l, mid, a);
            build(2 * p + 1, mid + 1, r, a);
            info[p] = info[2 * p] + info[2 * p + 1];//up
        }
    }

    Info query(int p, int l, int r, int L, int R){
        if(L > r || R < l){
            return Info();
        }
        if(L <= l && r <= R){
            return info[p];
        }
        int mid = (l + r) / 2;
        return query(2 * p, l, mid, L, R) + query(2 * p + 1, mid + 1, r, L, R);
    }
    //1-based
    Info query(int L, int R){
        return query(1, 1, n, L, R);
    }
};